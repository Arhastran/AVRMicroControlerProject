   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_2
  12               	__vector_2:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  Adam Ignaciuk 
   3:main.c        ****  Projek PSM 2021
   4:main.c        ****  Dioda RC5, odbieranie sygnału IR i wyświetlanie wartości na ekranie 
   5:main.c        ****  */
   6:main.c        **** #include <avr/io.h>              
   7:main.c        **** #include <avr/interrupt.h>
   8:main.c        **** #include <avr/delay.h>
   9:main.c        **** 
  10:main.c        **** 
  11:main.c        **** 
  12:main.c        **** volatile uint8_t RC5cmd;
  13:main.c        **** volatile uint8_t RC5addr;
  14:main.c        **** volatile uint8_t z;
  15:main.c        **** volatile unsigned char ready;
  16:main.c        **** volatile unsigned long int tmp;
  17:main.c        **** 
  18:main.c        **** SIGNAL(INT1_vect) 
  19:main.c        **** {
  15               		.loc 1 19 1 view -0
  16               		.cfi_startproc
  17 0000 0F92 0FB6 		__gcc_isr 1
  17      0F92 1F92 
  17      1124 0F93 
  18 000c 1F93      		push r17
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 17, -2
  22 000e 2F93      		push r18
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 18, -3
  26 0010 3F93      		push r19
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 19, -4
  30 0012 4F93      		push r20
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 20, -5
  34 0014 5F93      		push r21
  35               	.LCFI4:
  36               		.cfi_def_cfa_offset 7
  37               		.cfi_offset 21, -6
  38 0016 6F93      		push r22
  39               	.LCFI5:
  40               		.cfi_def_cfa_offset 8
  41               		.cfi_offset 22, -7
  42 0018 7F93      		push r23
  43               	.LCFI6:
  44               		.cfi_def_cfa_offset 9
  45               		.cfi_offset 23, -8
  46 001a 8F93      		push r24
  47               	.LCFI7:
  48               		.cfi_def_cfa_offset 10
  49               		.cfi_offset 24, -9
  50 001c 9F93      		push r25
  51               	.LCFI8:
  52               		.cfi_def_cfa_offset 11
  53               		.cfi_offset 25, -10
  54 001e AF93      		push r26
  55               	.LCFI9:
  56               		.cfi_def_cfa_offset 12
  57               		.cfi_offset 26, -11
  58 0020 BF93      		push r27
  59               	.LCFI10:
  60               		.cfi_def_cfa_offset 13
  61               		.cfi_offset 27, -12
  62 0022 EF93      		push r30
  63               	.LCFI11:
  64               		.cfi_def_cfa_offset 14
  65               		.cfi_offset 30, -13
  66               	/* prologue: Signal */
  67               	/* frame size = 0 */
  68               	/* stack size = 12...16 */
  69               	.L__stack_usage = 12 + __gcc_isr.n_pushed
  20:main.c        ****    uint16_t ilosc_bitow = 0;
  70               		.loc 1 20 4 view .LVU1
  71               	.LVL0:
  21:main.c        ****    uint8_t liczba_zboczy = 0;
  72               		.loc 1 21 4 view .LVU2
  22:main.c        ****    unsigned char mem_bit;
  73               		.loc 1 22 4 view .LVU3
  23:main.c        ****    uint8_t i = 1; // Jezeli nie ma bledu i = 1, jezeli jest => i = 0;
  74               		.loc 1 23 4 view .LVU4
  24:main.c        ****    
  25:main.c        ****    GICR &= ~_BV(INT1); //zamaskowanie przerwania INT1
  75               		.loc 1 25 4 view .LVU5
  76               		.loc 1 25 9 is_stmt 0 view .LVU6
  77 0024 8BB7      		in r24,0x3b
  78 0026 8F77      		andi r24,lo8(127)
  79 0028 8BBF      		out 0x3b,r24
  26:main.c        ****    TCCR0 = (1<<WGM01); //tryb CTC
  80               		.loc 1 26 4 is_stmt 1 view .LVU7
  81               		.loc 1 26 10 is_stmt 0 view .LVU8
  82 002a 88E0      		ldi r24,lo8(8)
  83 002c 83BF      		out 0x33,r24
  27:main.c        ****    TCCR0 = (1<<CS02); //preskaler 256
  84               		.loc 1 27 4 is_stmt 1 view .LVU9
  85               		.loc 1 27 10 is_stmt 0 view .LVU10
  86 002e 84E0      		ldi r24,lo8(4)
  87 0030 83BF      		out 0x33,r24
  28:main.c        ****    TCNT0 = 0; OCR0 = 81;// T=1,296ms ==> f=771,605Hz
  88               		.loc 1 28 4 is_stmt 1 view .LVU11
  89               		.loc 1 28 10 is_stmt 0 view .LVU12
  90 0032 12BE      		out 0x32,__zero_reg__
  91               		.loc 1 28 15 is_stmt 1 view .LVU13
  92               		.loc 1 28 20 is_stmt 0 view .LVU14
  93 0034 81E5      		ldi r24,lo8(81)
  94 0036 8CBF      		out 0x3c,r24
  29:main.c        **** 
  30:main.c        ****    tmp = 0;
  95               		.loc 1 30 4 is_stmt 1 view .LVU15
  96               		.loc 1 30 8 is_stmt 0 view .LVU16
  97 0038 1092 0000 		sts tmp,__zero_reg__
  98 003c 1092 0000 		sts tmp+1,__zero_reg__
  99 0040 1092 0000 		sts tmp+2,__zero_reg__
 100 0044 1092 0000 		sts tmp+3,__zero_reg__
  31:main.c        **** 
  32:main.c        ****    while(i)
 101               		.loc 1 32 4 is_stmt 1 view .LVU17
 102               		.loc 1 32 9 is_stmt 0 view .LVU18
 103 0048 4DE0      		ldi r20,lo8(13)
 104 004a 50E0      		ldi r21,0
  33:main.c        ****    {
  34:main.c        ****       mem_bit=(!(PIND & 0x08));
 105               		.loc 1 34 16 view .LVU19
 106 004c 61E0      		ldi r22,lo8(1)
  35:main.c        ****       liczba_zboczy = 0;
  36:main.c        ****       
  37:main.c        ****       TIFR |= (1<<OCF0); //kasowanie flagi przerwania przez wpisanie jedynki      
  38:main.c        **** 
  39:main.c        ****       while(TIFR&OCF0)  //!OCF0
  40:main.c        ****       {
  41:main.c        ****          if(mem_bit != ((!(PIND & 0x08))))
 107               		.loc 1 41 26 view .LVU20
 108 004e 71E0      		ldi r23,lo8(1)
  42:main.c        ****          {
  43:main.c        ****             liczba_zboczy++;
  44:main.c        ****             mem_bit=(!(PIND & 0x08));
  45:main.c        **** 
  46:main.c        ****             if(liczba_zboczy>1) //wiecej niz jedno zbocze
  47:main.c        ****             {
  48:main.c        ****                //W przyadku błędu 
  49:main.c        ****                i=0;
  50:main.c        ****                GICR |= (1<<INT1);  //odblokowanie przerwania INT1
  51:main.c        ****                return;
  52:main.c        ****             }
  53:main.c        ****          }
  54:main.c        ****       }
  55:main.c        ****       tmp<<=1;// przesuniecie wszystkich bitow o jeden w lewo
  56:main.c        ****       tmp |= mem_bit; 
  57:main.c        ****       TIFR |= (1<<OCF0); //kasowanie flagi przerwania przez wpisanie jedynki
  58:main.c        ****       
  59:main.c        ****       ilosc_bitow++;
  60:main.c        ****    
  61:main.c        ****       if(ilosc_bitow == 13)
  62:main.c        ****       {
  63:main.c        ****          RC5cmd = tmp&0x3f; //przyjmuje wartości w zależności od zebranych bitów
  64:main.c        ****          z = tmp;
  65:main.c        ****          RC5addr = (tmp>>6) & 0x1f;
  66:main.c        ****          ready = 1;
  67:main.c        ****          GICR |= (1<<INT1);  //odblokowanie przerwania INT1   
  68:main.c        ****          i=0;
  69:main.c        ****          return;   
  70:main.c        ****       } 
  71:main.c        ****      TCNT0 = 0; OCR0 = 81;// T=1,296ms ==> f=771,605Hz
 109               		.loc 1 71 22 view .LVU21
 110 0050 E1E5      		ldi r30,lo8(81)
 111               	.LVL1:
 112               	.L2:
  32:main.c        ****    {
 113               		.loc 1 32 9 is_stmt 1 view .LVU22
  34:main.c        ****       liczba_zboczy = 0;
 114               		.loc 1 34 7 view .LVU23
  34:main.c        ****       liczba_zboczy = 0;
 115               		.loc 1 34 18 is_stmt 0 view .LVU24
 116 0052 80B3      		in r24,0x10
  34:main.c        ****       liczba_zboczy = 0;
 117               		.loc 1 34 16 view .LVU25
 118 0054 83FB      		bst r24,3
 119 0056 8827      		clr r24
 120 0058 80F9      		bld r24,0
 121 005a 8627      		eor r24,r22
 122               	.LVL2:
  35:main.c        ****       
 123               		.loc 1 35 7 is_stmt 1 view .LVU26
  37:main.c        **** 
 124               		.loc 1 37 7 view .LVU27
  37:main.c        **** 
 125               		.loc 1 37 12 is_stmt 0 view .LVU28
 126 005c 98B7      		in r25,0x38
 127 005e 9260      		ori r25,lo8(2)
 128 0060 98BF      		out 0x38,r25
  39:main.c        ****       {
 129               		.loc 1 39 7 is_stmt 1 view .LVU29
  39:main.c        ****       {
 130               		.loc 1 39 12 is_stmt 0 view .LVU30
 131 0062 22E0      		ldi r18,lo8(2)
 132 0064 00C0      		rjmp .L10
 133               	.LVL3:
 134               	.L6:
  41:main.c        ****          {
 135               		.loc 1 41 10 is_stmt 1 view .LVU31
  41:main.c        ****          {
 136               		.loc 1 41 28 is_stmt 0 view .LVU32
 137 0066 90B3      		in r25,0x10
  41:main.c        ****          {
 138               		.loc 1 41 26 view .LVU33
 139 0068 93FB      		bst r25,3
 140 006a 9927      		clr r25
 141 006c 90F9      		bld r25,0
 142 006e 9627      		eor r25,r22
  41:main.c        ****          {
 143               		.loc 1 41 12 view .LVU34
 144 0070 9817      		cp r25,r24
 145 0072 01F0      		breq .L3
  43:main.c        ****             mem_bit=(!(PIND & 0x08));
 146               		.loc 1 43 13 is_stmt 1 view .LVU35
  44:main.c        **** 
 147               		.loc 1 44 13 view .LVU36
  44:main.c        **** 
 148               		.loc 1 44 24 is_stmt 0 view .LVU37
 149 0074 80B3      		in r24,0x10
 150               	.LVL4:
  44:main.c        **** 
 151               		.loc 1 44 22 view .LVU38
 152 0076 83FB      		bst r24,3
 153 0078 8827      		clr r24
 154 007a 80F9      		bld r24,0
 155 007c 8727      		eor r24,r23
 156               	.LVL5:
  46:main.c        ****             {
 157               		.loc 1 46 13 is_stmt 1 view .LVU39
  46:main.c        ****             {
 158               		.loc 1 46 15 is_stmt 0 view .LVU40
 159 007e 2130      		cpi r18,1
 160 0080 3105      		cpc r19,__zero_reg__
 161 0082 01F4      		brne .L8
 162               	.LVL6:
 163               	.L11:
  67:main.c        ****          i=0;
 164               		.loc 1 67 10 is_stmt 1 view .LVU41
  67:main.c        ****          i=0;
 165               		.loc 1 67 15 is_stmt 0 view .LVU42
 166 0084 8BB7      		in r24,0x3b
 167 0086 8068      		ori r24,lo8(-128)
 168 0088 8BBF      		out 0x3b,r24
  68:main.c        ****          return;   
 169               		.loc 1 68 10 is_stmt 1 view .LVU43
 170               	.LVL7:
  69:main.c        ****       } 
 171               		.loc 1 69 10 view .LVU44
 172               	/* epilogue start */
  72:main.c        **** 
  73:main.c        ****    }
  74:main.c        **** }
 173               		.loc 1 74 1 is_stmt 0 view .LVU45
 174 008a EF91      		pop r30
 175 008c BF91      		pop r27
 176 008e AF91      		pop r26
 177 0090 9F91      		pop r25
 178 0092 8F91      		pop r24
 179 0094 7F91      		pop r23
 180 0096 6F91      		pop r22
 181 0098 5F91      		pop r21
 182 009a 4F91      		pop r20
 183 009c 3F91      		pop r19
 184 009e 2F91      		pop r18
 185 00a0 1F91      		pop r17
 186 00a2 0F91 1F90 		__gcc_isr 2
 186      0F90 0FBE 
 186      0F90 
 187 00ac 1895      		reti
 188               	.LVL8:
 189               	.L8:
 190               		.loc 1 74 1 view .LVU46
 191 00ae 21E0      		ldi r18,lo8(1)
 192               	.L10:
 193               		.loc 1 74 1 view .LVU47
 194 00b0 30E0      		ldi r19,0
 195               	.L3:
  39:main.c        ****       {
 196               		.loc 1 39 12 is_stmt 1 view .LVU48
 197 00b2 08B6      		in __tmp_reg__,0x38
 198 00b4 00FC      		sbrc __tmp_reg__,0
 199 00b6 00C0      		rjmp .L6
  55:main.c        ****       tmp |= mem_bit; 
 200               		.loc 1 55 7 view .LVU49
  55:main.c        ****       tmp |= mem_bit; 
 201               		.loc 1 55 10 is_stmt 0 view .LVU50
 202 00b8 0091 0000 		lds r16,tmp
 203 00bc 1091 0000 		lds r17,tmp+1
 204 00c0 2091 0000 		lds r18,tmp+2
 205 00c4 3091 0000 		lds r19,tmp+3
 206 00c8 000F      		lsl r16
 207 00ca 111F      		rol r17
 208 00cc 221F      		rol r18
 209 00ce 331F      		rol r19
 210 00d0 0093 0000 		sts tmp,r16
 211 00d4 1093 0000 		sts tmp+1,r17
 212 00d8 2093 0000 		sts tmp+2,r18
 213 00dc 3093 0000 		sts tmp+3,r19
  56:main.c        ****       TIFR |= (1<<OCF0); //kasowanie flagi przerwania przez wpisanie jedynki
 214               		.loc 1 56 7 is_stmt 1 view .LVU51
  56:main.c        ****       TIFR |= (1<<OCF0); //kasowanie flagi przerwania przez wpisanie jedynki
 215               		.loc 1 56 11 is_stmt 0 view .LVU52
 216 00e0 0091 0000 		lds r16,tmp
 217 00e4 1091 0000 		lds r17,tmp+1
 218 00e8 2091 0000 		lds r18,tmp+2
 219 00ec 3091 0000 		lds r19,tmp+3
 220 00f0 082B      		or r16,r24
 221 00f2 0093 0000 		sts tmp,r16
 222 00f6 1093 0000 		sts tmp+1,r17
 223 00fa 2093 0000 		sts tmp+2,r18
 224 00fe 3093 0000 		sts tmp+3,r19
  57:main.c        ****       
 225               		.loc 1 57 7 is_stmt 1 view .LVU53
  57:main.c        ****       
 226               		.loc 1 57 12 is_stmt 0 view .LVU54
 227 0102 88B7      		in r24,0x38
 228               	.LVL9:
  57:main.c        ****       
 229               		.loc 1 57 12 view .LVU55
 230 0104 8260      		ori r24,lo8(2)
 231 0106 88BF      		out 0x38,r24
  59:main.c        ****    
 232               		.loc 1 59 7 is_stmt 1 view .LVU56
 233               	.LVL10:
  61:main.c        ****       {
 234               		.loc 1 61 7 view .LVU57
  61:main.c        ****       {
 235               		.loc 1 61 9 is_stmt 0 view .LVU58
 236 0108 4150      		subi r20,1
 237 010a 5109      		sbc r21,__zero_reg__
 238               	.LVL11:
  61:main.c        ****       {
 239               		.loc 1 61 9 view .LVU59
 240 010c 01F4      		brne .L7
  63:main.c        ****          z = tmp;
 241               		.loc 1 63 10 is_stmt 1 view .LVU60
  63:main.c        ****          z = tmp;
 242               		.loc 1 63 22 is_stmt 0 view .LVU61
 243 010e 8091 0000 		lds r24,tmp
 244 0112 9091 0000 		lds r25,tmp+1
 245 0116 A091 0000 		lds r26,tmp+2
 246 011a B091 0000 		lds r27,tmp+3
 247 011e 8F73      		andi r24,lo8(63)
  63:main.c        ****          z = tmp;
 248               		.loc 1 63 17 view .LVU62
 249 0120 8093 0000 		sts RC5cmd,r24
  64:main.c        ****          RC5addr = (tmp>>6) & 0x1f;
 250               		.loc 1 64 10 is_stmt 1 view .LVU63
  64:main.c        ****          RC5addr = (tmp>>6) & 0x1f;
 251               		.loc 1 64 12 is_stmt 0 view .LVU64
 252 0124 8091 0000 		lds r24,tmp
 253 0128 9091 0000 		lds r25,tmp+1
 254 012c A091 0000 		lds r26,tmp+2
 255 0130 B091 0000 		lds r27,tmp+3
 256 0134 8093 0000 		sts z,r24
  65:main.c        ****          ready = 1;
 257               		.loc 1 65 10 is_stmt 1 view .LVU65
  65:main.c        ****          ready = 1;
 258               		.loc 1 65 24 is_stmt 0 view .LVU66
 259 0138 8091 0000 		lds r24,tmp
 260 013c 9091 0000 		lds r25,tmp+1
 261 0140 A091 0000 		lds r26,tmp+2
 262 0144 B091 0000 		lds r27,tmp+3
 263 0148 26E0      		ldi r18,6
 264               		1:
 265 014a B695      		lsr r27
 266 014c A795      		ror r26
 267 014e 9795      		ror r25
 268 0150 8795      		ror r24
 269 0152 2A95      		dec r18
 270 0154 01F4      		brne 1b
  65:main.c        ****          ready = 1;
 271               		.loc 1 65 29 view .LVU67
 272 0156 8F71      		andi r24,lo8(31)
  65:main.c        ****          ready = 1;
 273               		.loc 1 65 18 view .LVU68
 274 0158 8093 0000 		sts RC5addr,r24
  66:main.c        ****          GICR |= (1<<INT1);  //odblokowanie przerwania INT1   
 275               		.loc 1 66 10 is_stmt 1 view .LVU69
  66:main.c        ****          GICR |= (1<<INT1);  //odblokowanie przerwania INT1   
 276               		.loc 1 66 16 is_stmt 0 view .LVU70
 277 015c 81E0      		ldi r24,lo8(1)
 278 015e 8093 0000 		sts ready,r24
 279 0162 00C0      		rjmp .L11
 280               	.L7:
  71:main.c        **** 
 281               		.loc 1 71 6 is_stmt 1 view .LVU71
  71:main.c        **** 
 282               		.loc 1 71 12 is_stmt 0 view .LVU72
 283 0164 12BE      		out 0x32,__zero_reg__
  71:main.c        **** 
 284               		.loc 1 71 17 is_stmt 1 view .LVU73
  71:main.c        **** 
 285               		.loc 1 71 22 is_stmt 0 view .LVU74
 286 0166 ECBF      		out 0x3c,r30
 287 0168 00C0      		rjmp .L2
 288               		__gcc_isr 0,r16
 289               		.cfi_endproc
 290               	.LFE6:
 292               		.section	.rodata.str1.1,"aMS",@progbits,1
 293               	.LC0:
 294 0000 5365 6E64 		.string	"Send IR signal"
 294      2049 5220 
 294      7369 676E 
 294      616C 00
 295               	.LC1:
 296 000f 5369 676E 		.string	"Signal detected"
 296      616C 2064 
 296      6574 6563 
 296      7465 6400 
 297               	.LC2:
 298 001f 2000      		.string	" "
 299               		.section	.text.startup,"ax",@progbits
 300               	.global	main
 302               	main:
 303               	.LFB7:
  75:main.c        **** 
  76:main.c        **** int main(void)
  77:main.c        **** {
 304               		.loc 1 77 1 is_stmt 1 view -0
 305               		.cfi_startproc
 306               	/* prologue: function */
 307               	/* frame size = 0 */
 308               	/* stack size = 0 */
 309               	.L__stack_usage = 0
  78:main.c        ****    DDRA &= ~(1<<0);
 310               		.loc 1 78 4 view .LVU76
 311               		.loc 1 78 9 is_stmt 0 view .LVU77
 312 0000 D098      		cbi 0x1a,0
  79:main.c        ****    DDRD = 0x00; //wejscia
 313               		.loc 1 79 4 is_stmt 1 view .LVU78
 314               		.loc 1 79 9 is_stmt 0 view .LVU79
 315 0002 11BA      		out 0x11,__zero_reg__
  80:main.c        ****    GICR |= (1<<INT1);  //odblokowanie przerwania INT1   
 316               		.loc 1 80 4 is_stmt 1 view .LVU80
 317               		.loc 1 80 9 is_stmt 0 view .LVU81
 318 0004 8BB7      		in r24,0x3b
 319 0006 8068      		ori r24,lo8(-128)
 320 0008 8BBF      		out 0x3b,r24
  81:main.c        ****    MCUCR |= ((1<<ISC11)&(1<<ISC00)&(1<<ISC01)&(1<<ISC10)); // Przerwanie przy dowolnym zboczu 
 321               		.loc 1 81 4 is_stmt 1 view .LVU82
 322               		.loc 1 81 10 is_stmt 0 view .LVU83
 323 000a 85B7      		in r24,0x35
 324 000c 85BF      		out 0x35,r24
  82:main.c        ****    uint8_t volume = 0;
 325               		.loc 1 82 4 is_stmt 1 view .LVU84
 326               	.LVL12:
  83:main.c        ****    uint8_t numerator = 0;
 327               		.loc 1 83 4 view .LVU85
  84:main.c        ****    lcdinit();
 328               		.loc 1 84 4 view .LVU86
 329 000e 0E94 0000 		call lcdinit
 330               	.LVL13:
  85:main.c        ****    lcd_clr();
 331               		.loc 1 85 4 view .LVU87
 332 0012 0E94 0000 		call lcd_clr
 333               	.LVL14:
  86:main.c        ****    sei();
 334               		.loc 1 86 4 view .LVU88
 335               	/* #APP */
 336               	 ;  86 "main.c" 1
 337 0016 7894      		sei
 338               	 ;  0 "" 2
  87:main.c        ****    
  88:main.c        ****    lcd_text("Send IR signal");
 339               		.loc 1 88 4 view .LVU89
 340               	/* #NOAPP */
 341 0018 80E0      		ldi r24,lo8(.LC0)
 342 001a 90E0      		ldi r25,hi8(.LC0)
 343 001c 0E94 0000 		call lcd_text
 344               	.LVL15:
  82:main.c        ****    uint8_t numerator = 0;
 345               		.loc 1 82 12 is_stmt 0 view .LVU90
 346 0020 C0E0      		ldi r28,0
 347               	.LVL16:
 348               	.L13:
  89:main.c        ****   
  90:main.c        ****    while(1)
 349               		.loc 1 90 4 is_stmt 1 view .LVU91
  91:main.c        ****    {
  92:main.c        ****       if(ready)
 350               		.loc 1 92 7 view .LVU92
 351               		.loc 1 92 10 is_stmt 0 view .LVU93
 352 0022 8091 0000 		lds r24,ready
 353               		.loc 1 92 9 view .LVU94
 354 0026 8823      		tst r24
 355 0028 01F0      		breq .L13
  93:main.c        ****       {
  94:main.c        **** 		  lcd_clr();
 356               		.loc 1 94 5 is_stmt 1 view .LVU95
 357 002a 0E94 0000 		call lcd_clr
 358               	.LVL17:
  95:main.c        **** 		  if (RC5cmd==16) // zwiększenie natężęnia dźwięku (vol up)
 359               		.loc 1 95 5 view .LVU96
 360               		.loc 1 95 15 is_stmt 0 view .LVU97
 361 002e 8091 0000 		lds r24,RC5cmd
 362               		.loc 1 95 8 view .LVU98
 363 0032 8031      		cpi r24,lo8(16)
 364 0034 01F4      		brne .L14
 365               	.LBB8:
  96:main.c        **** 		  {
  97:main.c        **** 			  lcd_text("Signal detected");
 366               		.loc 1 97 6 is_stmt 1 view .LVU99
 367 0036 80E0      		ldi r24,lo8(.LC1)
 368 0038 90E0      		ldi r25,hi8(.LC1)
 369 003a 0E94 0000 		call lcd_text
 370               	.LVL18:
  98:main.c        **** 			  goto_xy(0,1);
 371               		.loc 1 98 6 view .LVU100
 372 003e 61E0      		ldi r22,lo8(1)
 373 0040 70E0      		ldi r23,0
 374 0042 90E0      		ldi r25,0
 375 0044 80E0      		ldi r24,0
 376 0046 0E94 0000 		call goto_xy
 377               	.LVL19:
  99:main.c        **** 			  lcd_int(RC5cmd);
 378               		.loc 1 99 6 view .LVU101
 379 004a 8091 0000 		lds r24,RC5cmd
 380 004e 90E0      		ldi r25,0
 381 0050 0E94 0000 		call lcd_int
 382               	.LVL20:
 100:main.c        **** 			  if (volume<101) volume+=1;
 383               		.loc 1 100 6 view .LVU102
 384               		.loc 1 100 9 is_stmt 0 view .LVU103
 385 0054 C536      		cpi r28,lo8(101)
 386 0056 00F4      		brsh .L20
 387               		.loc 1 100 22 is_stmt 1 discriminator 1 view .LVU104
 388               		.loc 1 100 28 is_stmt 0 discriminator 1 view .LVU105
 389 0058 CF5F      		subi r28,lo8(-(1))
 390               	.LVL21:
 391               	.L25:
 392               		.loc 1 100 28 discriminator 1 view .LVU106
 393               	.LBE8:
 394               	.LBB9:
 101:main.c        **** 			  else volume =100;
 102:main.c        **** 			  lcd_text(" ");
 103:main.c        **** 			  lcd_int(volume);
 104:main.c        **** 		  }
 105:main.c        **** 		  else if (RC5cmd==17)// zmniejszanie natężęnia dźwięku (vol down)
 106:main.c        **** 		  {
 107:main.c        **** 			  lcd_text("Signal detected");
 108:main.c        **** 			  goto_xy(0,1);
 109:main.c        **** 			  lcd_int(RC5cmd);
 110:main.c        **** 			  if (volume>-1) volume-=1;
 111:main.c        **** 			  else volume =0;
 112:main.c        **** 			  lcd_text(" ");
 395               		.loc 1 112 6 is_stmt 1 view .LVU107
 396 005a 80E0      		ldi r24,lo8(.LC2)
 397 005c 90E0      		ldi r25,hi8(.LC2)
 398 005e 0E94 0000 		call lcd_text
 399               	.LVL22:
 113:main.c        **** 			  lcd_int(volume);
 400               		.loc 1 113 6 view .LVU108
 401 0062 8C2F      		mov r24,r28
 402               	.L23:
 403               		.loc 1 113 6 is_stmt 0 view .LVU109
 404               	.LBE9:
 405               	.LBB10:
 114:main.c        **** 		  }
 115:main.c        **** 		   else if (RC5cmd==53)// zapalanie diody (play)
 116:main.c        **** 		  {
 117:main.c        **** 			  lcd_text("Signal detected");
 118:main.c        **** 			  goto_xy(0,1);
 119:main.c        **** 			  if (numerator = 0) 
 120:main.c        **** 			  {
 121:main.c        **** 				PORTA &= ~(1<<PINA0);
 122:main.c        **** 				numerator = 1; 
 123:main.c        **** 			  }
 124:main.c        **** 			  else 
 125:main.c        **** 			  {
 126:main.c        **** 				PORTA &=(1<<PINA0); 
 127:main.c        **** 				numerator = 0;  
 128:main.c        **** 			  }
 129:main.c        **** 			  lcd_int(RC5cmd);
 130:main.c        **** 		  }
 131:main.c        **** 		   else 
 132:main.c        **** 		  {
 133:main.c        **** 			  lcd_text("Signal detected");
 134:main.c        **** 			  goto_xy(0,1);
 135:main.c        **** 			  lcd_int(RC5cmd);
 406               		.loc 1 135 6 view .LVU110
 407 0064 90E0      		ldi r25,0
 408 0066 0E94 0000 		call lcd_int
 409               	.LVL23:
 410               		.loc 1 135 6 view .LVU111
 411               	.LBE10:
 136:main.c        **** 		  }
 137:main.c        **** 	      _delay_ms(1000);
 412               		.loc 1 137 8 is_stmt 1 view .LVU112
 413               	.LBB11:
 414               	.LBI11:
 415               		.file 2 "c:\\avr-gcc-10.1.0-x64-windows\\avr\\include\\util\\delay.h"
   1:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    All rights reserved.
   5:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
   6:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
   9:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  12:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      distribution.
  16:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  17:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  21:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  33:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /* $Id$ */
  34:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  35:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  38:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #  endif
  42:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  44:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #include <math.h>
  47:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  48:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /** \file */
  49:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \code
  51:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \endcode
  55:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  56:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     used.
  60:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  61:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  70:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  79:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  83:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** */
  84:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  85:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
  89:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  90:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \def F_CPU
  95:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  97:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 103:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     integer value.
 107:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****  */
 108:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
 110:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 111:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
 114:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 115:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #  include <math.h>
 119:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
 120:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 121:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /**
 122:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 124:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 126:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 129:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 131:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 137:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 142:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 147:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    respectively.
 151:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 152:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \note
 153:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 154:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 164:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****  */
 165:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** void
 166:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** _delay_ms(double __ms)
 416               		.loc 2 166 1 view .LVU113
 417               	.LBB12:
 167:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 168:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	double __tmp ;
 418               		.loc 2 168 2 view .LVU114
 169:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 419               		.loc 2 172 2 view .LVU115
 173:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 420               		.loc 2 173 2 view .LVU116
 174:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 421               		.loc 2 174 2 view .LVU117
 175:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 176:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 179:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 182:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#else
 183:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		//round up by default
 184:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 422               		.loc 2 184 3 view .LVU118
 185:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 186:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 187:c:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 423               		.loc 2 187 2 view .LVU119
 424 006a 2FEF      		ldi r18,lo8(3199999)
 425 006c 83ED      		ldi r24,hi8(3199999)
 426 006e 90E3      		ldi r25,hlo8(3199999)
 427 0070 2150      	1:	subi r18,1
 428 0072 8040      		sbci r24,0
 429 0074 9040      		sbci r25,0
 430 0076 01F4      		brne 1b
 431 0078 00C0      		rjmp .
 432 007a 0000      		nop
 433               	.LVL24:
 434               		.loc 2 187 2 is_stmt 0 view .LVU120
 435               	.LBE12:
 436               	.LBE11:
 138:main.c        ****           ready = 0;
 437               		.loc 1 138 11 is_stmt 1 view .LVU121
 438               		.loc 1 138 17 is_stmt 0 view .LVU122
 439 007c 1092 0000 		sts ready,__zero_reg__
 440 0080 00C0      		rjmp .L13
 441               	.L20:
 442               	.LBB13:
 101:main.c        **** 			  lcd_text(" ");
 443               		.loc 1 101 18 view .LVU123
 444 0082 C4E6      		ldi r28,lo8(100)
 445               	.LVL25:
 102:main.c        **** 			  lcd_int(volume);
 446               		.loc 1 102 6 is_stmt 1 view .LVU124
 447 0084 00C0      		rjmp .L25
 448               	.L14:
 102:main.c        **** 			  lcd_int(volume);
 449               		.loc 1 102 6 is_stmt 0 view .LVU125
 450               	.LBE13:
 105:main.c        **** 		  {
 451               		.loc 1 105 10 is_stmt 1 view .LVU126
 105:main.c        **** 		  {
 452               		.loc 1 105 20 is_stmt 0 view .LVU127
 453 0086 8091 0000 		lds r24,RC5cmd
 105:main.c        **** 		  {
 454               		.loc 1 105 13 view .LVU128
 455 008a 8131      		cpi r24,lo8(17)
 456 008c 01F4      		brne .L17
 457               	.LBB14:
 107:main.c        **** 			  goto_xy(0,1);
 458               		.loc 1 107 6 is_stmt 1 view .LVU129
 459 008e 80E0      		ldi r24,lo8(.LC1)
 460 0090 90E0      		ldi r25,hi8(.LC1)
 461 0092 0E94 0000 		call lcd_text
 462               	.LVL26:
 108:main.c        **** 			  lcd_int(RC5cmd);
 463               		.loc 1 108 6 view .LVU130
 464 0096 61E0      		ldi r22,lo8(1)
 465 0098 70E0      		ldi r23,0
 466 009a 90E0      		ldi r25,0
 467 009c 80E0      		ldi r24,0
 468 009e 0E94 0000 		call goto_xy
 469               	.LVL27:
 109:main.c        **** 			  if (volume>-1) volume-=1;
 470               		.loc 1 109 6 view .LVU131
 471 00a2 8091 0000 		lds r24,RC5cmd
 472 00a6 90E0      		ldi r25,0
 473 00a8 0E94 0000 		call lcd_int
 474               	.LVL28:
 110:main.c        **** 			  else volume =0;
 475               		.loc 1 110 6 view .LVU132
 110:main.c        **** 			  else volume =0;
 476               		.loc 1 110 21 view .LVU133
 110:main.c        **** 			  else volume =0;
 477               		.loc 1 110 27 is_stmt 0 view .LVU134
 478 00ac C150      		subi r28,lo8(-(-1))
 479               	.LVL29:
 110:main.c        **** 			  else volume =0;
 480               		.loc 1 110 27 view .LVU135
 481 00ae 00C0      		rjmp .L25
 482               	.LVL30:
 483               	.L17:
 110:main.c        **** 			  else volume =0;
 484               		.loc 1 110 27 view .LVU136
 485               	.LBE14:
 115:main.c        **** 		  {
 486               		.loc 1 115 11 is_stmt 1 view .LVU137
 115:main.c        **** 		  {
 487               		.loc 1 115 21 is_stmt 0 view .LVU138
 488 00b0 8091 0000 		lds r24,RC5cmd
 115:main.c        **** 		  {
 489               		.loc 1 115 14 view .LVU139
 490 00b4 8533      		cpi r24,lo8(53)
 491 00b6 01F4      		brne .L18
 492               	.LBB15:
 117:main.c        **** 			  goto_xy(0,1);
 493               		.loc 1 117 6 is_stmt 1 view .LVU140
 494 00b8 80E0      		ldi r24,lo8(.LC1)
 495 00ba 90E0      		ldi r25,hi8(.LC1)
 496 00bc 0E94 0000 		call lcd_text
 497               	.LVL31:
 118:main.c        **** 			  if (numerator = 0) 
 498               		.loc 1 118 6 view .LVU141
 499 00c0 61E0      		ldi r22,lo8(1)
 500 00c2 70E0      		ldi r23,0
 501 00c4 90E0      		ldi r25,0
 502 00c6 80E0      		ldi r24,0
 503 00c8 0E94 0000 		call goto_xy
 504               	.LVL32:
 119:main.c        **** 			  {
 505               		.loc 1 119 6 view .LVU142
 126:main.c        **** 				numerator = 0;  
 506               		.loc 1 126 5 view .LVU143
 126:main.c        **** 				numerator = 0;  
 507               		.loc 1 126 11 is_stmt 0 view .LVU144
 508 00cc 8BB3      		in r24,0x1b
 509 00ce 8170      		andi r24,lo8(1)
 510 00d0 8BBB      		out 0x1b,r24
 127:main.c        **** 			  }
 511               		.loc 1 127 5 is_stmt 1 view .LVU145
 129:main.c        **** 		  }
 512               		.loc 1 129 6 view .LVU146
 513               	.L24:
 514               	.LBE15:
 515               	.LBB16:
 135:main.c        **** 		  }
 516               		.loc 1 135 6 view .LVU147
 517 00d2 8091 0000 		lds r24,RC5cmd
 518 00d6 00C0      		rjmp .L23
 519               	.L18:
 133:main.c        **** 			  goto_xy(0,1);
 520               		.loc 1 133 6 view .LVU148
 521 00d8 80E0      		ldi r24,lo8(.LC1)
 522 00da 90E0      		ldi r25,hi8(.LC1)
 523 00dc 0E94 0000 		call lcd_text
 524               	.LVL33:
 134:main.c        **** 			  lcd_int(RC5cmd);
 525               		.loc 1 134 6 view .LVU149
 526 00e0 61E0      		ldi r22,lo8(1)
 527 00e2 70E0      		ldi r23,0
 528 00e4 90E0      		ldi r25,0
 529 00e6 80E0      		ldi r24,0
 530 00e8 0E94 0000 		call goto_xy
 531               	.LVL34:
 532 00ec 00C0      		rjmp .L24
 533               	.LBE16:
 534               		.cfi_endproc
 535               	.LFE7:
 537               	.global	tmp
 538               		.section .bss
 541               	tmp:
 542 0000 0000 0000 		.zero	4
 543               	.global	ready
 546               	ready:
 547 0004 00        		.zero	1
 548               	.global	z
 551               	z:
 552 0005 00        		.zero	1
 553               	.global	RC5addr
 556               	RC5addr:
 557 0006 00        		.zero	1
 558               	.global	RC5cmd
 561               	RC5cmd:
 562 0007 00        		.zero	1
 563               		.text
 564               	.Letext0:
 565               		.file 3 "c:\\avr-gcc-10.1.0-x64-windows\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:2      *ABS*:000000000000003e __SP_H__
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:3      *ABS*:000000000000003d __SP_L__
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:4      *ABS*:000000000000003f __SREG__
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:5      *ABS*:0000000000000000 __tmp_reg__
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:6      *ABS*:0000000000000001 __zero_reg__
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:12     .text:0000000000000000 __vector_2
                            *ABS*:0000000000000004 __gcc_isr.n_pushed.001
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:541    .bss:0000000000000000 tmp
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:561    .bss:0000000000000007 RC5cmd
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:551    .bss:0000000000000005 z
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:556    .bss:0000000000000006 RC5addr
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:546    .bss:0000000000000004 ready
C:\Users\toaad\AppData\Local\Temp\ccfQjVx0.s:302    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
lcdinit
lcd_clr
lcd_text
goto_xy
lcd_int
__do_copy_data
__do_clear_bss
